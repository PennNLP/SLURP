"""Process MetaPAR and LTL data."""

import subprocess
import math
from collections import defaultdict

from fsa import BIT_PREFIX, ROOM_PREFIX, BIT_ROOM_RE, ROOM_RE

# Compress room propositions into bits
COMPRESS_ROOMS = True

# Automaton compilation executable
AUTOMATON_GEN = (r"java -ea -Xmx1g -cp %s/jtlv-prompt1.4.0.jar:"
                 r"%s/GROne GROneMain")

# LTL Constants
ALWAYS = "[]"
FINALLY = "<>"
TO = "->"
IFF = "<->"
NOT = "!"
AND = "&"
END = " &" # And goes at end of lines
OR = "|"
ROBOT_STATE = "s."
ENV_STATE = "e."
ASSUMPTIONS_START = \
"""-- LTL specification file
-- (Generated by LTLBroom)

LTLSPEC -- Assumptions
("""
ASSUMPTIONS_END = \
"""[](TRUE) &
[]<>(TRUE)
);"""
GUARANTEES_START = \
"""
LTLSPEC -- Guarantees
("""
GUARANTEES_END = \
"""
);"""

SMV_HEADER = \
"""-- SMV specifcation file
-- (Generated by LTLBroom)

MODULE main
VAR
e : env();
s : sys();

MODULE env -- inputs
VAR"""

SMV_MIDDLE = \
"""
MODULE sys -- outputs
VAR"""

# Scenario propositions
DONE_PROP = "done"
WORK_PROP = "work"
SEARCH_PROP = "search"
SEARCH_DONE_SENSOR = SEARCH_PROP + "_done"
SEARCH_PREFIX = "s_"
FOLLOW_PROP = "follow_me"
FOLLOW_DONE_SENSOR = FOLLOW_PROP + "_done"
GET_DONE_SENSOR = "get_obj_done"
EXPLORE_PROP = "explore"
EXPLORE_COMPLETE_PROP = EXPLORE_PROP + "_complete"
EXPLORE_REGION = "floor"

# File endings
SMV_ENDING = ".smv"
LTL_ENDING = ".ltl"
AUT_ENDING = ".aut"


class UnrealizableError(Exception):
    """Exception to be raised if a specification is unrealizable."""
    pass


class LTLGenerator:
    """Allows generation of LTL from specifications."""

    def __init__(self, rooms, room_adjacency, go_command, get_commands, search_commands, follow_command,
                 other_commands):
        self.rooms = rooms
        self.room_adjacency = room_adjacency
        self.room_map, self.room_props = _gen_room_props(rooms)
        
        # Store inverted room_nums if needed
        self.num_rooms = dict(enumerate(rooms))
        
        # Info about the commands
        self.go_command = go_command
        self.get_commands = get_commands
        self.follow_command = follow_command
        self.explore = False
        self.search_commands = search_commands
        self.other_commands = other_commands
        
        # LTL structures to be filled in during generation
        self.search_props = None
        self.search_rooms = None
        self.get_sensors = None
        self.get_props = None
        self.get_done_sensors = None
        self.get_have_props = None
        self.standing_sensors = None
        self.standing_actuators = None
        self.all_sensors = None
        self.all_nonroom_props = None

    def _generate_smv_file(self, file_prefix):
        """Write out the SMV file."""
        smv_file = open(file_prefix + SMV_ENDING, 'w')
        print >> smv_file, SMV_HEADER
        self.all_sensors = self.get_sensors + self.standing_sensors + self.get_done_sensors
        if self.search_commands:
            self.all_sensors += [SEARCH_DONE_SENSOR]
        if self.follow_command:
            self.all_sensors += [FOLLOW_DONE_SENSOR]           
        
        for sensor in self.all_sensors:
            print >> smv_file, sensor, ": boolean;"
        
        print >> smv_file, SMV_MIDDLE
        
        custom_props = self.search_props + self.get_have_props + [WORK_PROP, DONE_PROP]
        actuators = self.get_props + self.standing_actuators
        if self.search_commands:
            actuators += [SEARCH_PROP]
        if self.follow_command:
            actuators += [FOLLOW_PROP]
        if self.explore:
            actuators += [EXPLORE_PROP, EXPLORE_COMPLETE_PROP]
            
        self.all_nonroom_props = custom_props + actuators
        # Include rooms if we are not following
        props = self.all_nonroom_props if self.follow_command or self.explore \
            else self.room_props + self.all_nonroom_props
        for prop in props:
            print >> smv_file, prop, ": boolean;"
        
        smv_file.close()
        return (custom_props, actuators)

    def _generate_assumptions(self, ltl_file):
        """Generate the assumptions."""
        print >> ltl_file, ASSUMPTIONS_START
        if self.search_props: 
            # Search always completes
            print >> ltl_file, "-- Search eventually completes"
            print >> ltl_file, _always_finally(_env(SEARCH_DONE_SENSOR)) + END
        
        for get_prop, get_sensor in zip(self.get_props, self.get_sensors):    
            # Gets eventually complete after they're started
            print >> ltl_file, "-- %s only is done after it's initiated" % get_prop
            print >> ltl_file, _always_finally(_implies(_sys(get_prop), _env(GET_DONE_SENSOR))) + END
            print >> ltl_file, _always(_implies(_not(_sys(get_prop)), _not(_next(_env(GET_DONE_SENSOR))))) + END
            # The owner of an item doesn't disappear while you're trying to get it
            print >> ltl_file, "-- %s owners don't run away while we're trying to get items" % get_prop
            print >> ltl_file, _always(_implies(_and([_sys(get_prop), _not(_next(_env(GET_DONE_SENSOR)))]), _next(_env(get_sensor)))) + END
            print >> ltl_file

        if self.follow_command:
            # Once follow is done, stay done
            print >> ltl_file, "-- Following always finishes and stays done"
            print >> ltl_file, _always(_implies(_env(FOLLOW_DONE_SENSOR), 
                                                _next(_env(FOLLOW_DONE_SENSOR)))) + END
                                                
            # Following eventually finishes
            print >> ltl_file, _always_finally(_env(FOLLOW_DONE_SENSOR)) + END
            print >> ltl_file
        
        # Standing order sensors eventually turn off
        for sensor in self.standing_sensors:
            print >> ltl_file, _always_finally(_not(_env(sensor))) + END
        
        print >> ltl_file, ASSUMPTIONS_END

    def _generate_starting_state(self, init_room, init_props, ltl_file):
        """Generate the starting state."""
        # Write rooms if not following
        if not (self.follow_command or self.explore):   
            if COMPRESS_ROOMS:
                print >> ltl_file, "-- Compressed room map:"
                for room in self.rooms:
                    print >> ltl_file, "-- %s: %s" % (room, self.room_map[room])
                print >> ltl_file
                starting_rooms = self.room_map[init_room]
            else:
                starting_rooms = _and([(self.room_map[init_room])] + 
                                      [_not(prop) for (room, prop) in self.room_map.items() 
                                       if room != init_room])
            print >> ltl_file, "-- Starting state" # Start in initial room and not done 
            print >> ltl_file, starting_rooms + END
        
        # Set the starting state based on init_props
        default_off_props = (self.get_props + self.get_have_props + self.search_props + 
                             self.standing_actuators + [WORK_PROP, DONE_PROP])
        if self.search_props:
            default_off_props += [SEARCH_PROP]
        if self.follow_command:
            default_off_props += [FOLLOW_PROP]
            
        start_state_off_props = [_not(_sys(prop)) for prop in  default_off_props 
                                 if prop not in init_props]
        print >> ltl_file, _and(start_state_off_props) + END
        
        if init_props:
            print >> ltl_file, "-- Propositions carried over from previous automaton"
            start_state_on_props = [_sys(prop) for prop in init_props]
            print >> ltl_file, _and(start_state_on_props) + END

        print >> ltl_file

    def _generate_work_definition(self, ltl_file):
        """Generate the definition of working."""
        work_props = [_next(_sys(prop)) for prop in self.get_props + self.standing_actuators]
        if self.search_commands:
            work_props += [_next(_sys(SEARCH_PROP))]
            
        # Only put it out if there were actually any work props
        if work_props:
            print >> ltl_file, "-- Define working"
            print >> ltl_file, _always(_iff(_next(_sys(WORK_PROP)), _or(work_props))) + END
            print >> ltl_file

    def _generate_movement(self, full_room_props, ltl_file):
        """Generate the spatial/movement constraints."""
        # No spatial information if following
        if not (self.follow_command or self.explore):
            # Movement mutex
            print >> ltl_file, "-- Movement mutex"
            print >> ltl_file, _mutex([room for room in full_room_props]) + END
            print >> ltl_file
            
            # Room connectivity- need to build a structure from adjacency first
            room_connectivity = defaultdict(list)
            for room1, room2 in self.room_adjacency:
                room_connectivity[room1].append(room2)
                room_connectivity[room2].append(room1)
            
            print >> ltl_file, "-- Room connectivity"
            for room, neighbors in sorted(room_connectivity.items()):
                # Add self to connections
                neighbors.append(room)
                adjacent_rooms = _or([_next(self.room_map[room2]) for room2 in neighbors])
                print >> ltl_file, _always(self.room_map[room] + _space(TO) + adjacent_rooms) + END
        
            print >> ltl_file
                
        # Don't follow and work at the same time
        if self.follow_command:
            print >> ltl_file, "-- Do not work while following"
            print >> ltl_file, _always(_iff(_not(_next(_sys(WORK_PROP))), 
                                                _next(_sys(FOLLOW_PROP)))) + END
        # But you can explore and work at the same time
        elif self.explore:
            print >> ltl_file, "-- Once you start exploring, don't stop."
            print >> ltl_file, _always(_implies(_sys(EXPLORE_PROP), 
                                                _or([_next(_sys(EXPLORE_PROP)), _next(_env(SEARCH_DONE_SENSOR))]))) + END
        else:
            # Stay in the same place if work is set or you're about to be done
            print >> ltl_file, "-- Do not move while working or at the very end"
            stay_props = [_iff(room, _next(room)) for room in full_room_props]
            print >> ltl_file, _always(_implies(_or([_sys(WORK_PROP), _next(_sys(WORK_PROP)), 
                                                     _next(_sys(DONE_PROP))]), _and(stay_props))) + END

        print >> ltl_file


    def _generate_search(self, ltl_file):
        """Generate propositions for setting and propagating search flags."""        
        print >> ltl_file, "-- Maintain search flags"
        # Special case for explore, just wait on sensor
        if self.explore:
            print >> ltl_file, _always(_iff(_or([_and([_sys(EXPLORE_PROP), 
                    _next(_env(SEARCH_DONE_SENSOR))]), _sys(SEARCH_PREFIX + self.search_rooms[0])]), 
                    _next(_sys(SEARCH_PREFIX + self.search_rooms[0])))) + END
        else:
            for room in self.search_rooms:
                room_prop = self.room_map[room]
                print >> ltl_file, _always(_iff(_or([_and([room_prop, _sys(SEARCH_PROP), 
                    _next(_env(SEARCH_DONE_SENSOR))]), _sys(SEARCH_PREFIX + room)]), 
                    _next(_sys(SEARCH_PREFIX + room)))) + END
        
        print >> ltl_file

    def _generate_get(self, ltl_file):
        """"Generate orders for getting items."""
        if self.get_commands:
            print >> ltl_file, "-- Get each item"
            for owner, get, have in zip(self.get_sensors, self.get_props, self.get_have_props):
                print >> ltl_file, _always(_iff(_and([_not(_sys(have)), _next(_env(owner))]), _next(_sys(get)))) + END
                print >> ltl_file, _always(_iff(_or([_and([_sys(get), _next(_env(GET_DONE_SENSOR))]), _sys(have)]), _next(_sys(have)))) + END
            
            print >> ltl_file
            
    def _generate_standing_orders(self, ltl_file):
        """"Generate standing orders."""
        print >> ltl_file, "-- Standing orders"
        for action, target in self.other_commands:
            print >> ltl_file, _always(_iff(_next(_env(target)), _next(_sys(action)))) + END
        print >> ltl_file

    def _generate_goals(self, ltl_file):
        """Generate the goals."""
        print >> ltl_file, "-- Goal" # Goal state
        # Get goals
        goals = []
        if self.follow_command:
            goals += [_sys(FOLLOW_PROP), _next(_env(FOLLOW_DONE_SENSOR))]
        elif self.get_commands:
            goals += ([_or([_and(_sys(have) for have in self.get_have_props)] + 
                          [_and(_sys(SEARCH_PREFIX + room) for room in self.search_rooms)])])
        elif self.search_rooms:
            goals += ([_and(_sys(SEARCH_PREFIX + room) for room in self.search_rooms)])

            
        # Move to the final room
        if self.go_command:
            # TODO: Check whether it was right to remove _next(self.room_map[self.go_command])
            goals += [self.room_map[self.go_command]]
        
        # Output goals or bail
        if not goals:
            raise ValueError("Couldn't come up with a goal state.")
        else:
            # Sneak in not working after the check
            goals += [_not(_next(_sys(WORK_PROP)))]
            
            print >> ltl_file, _always(_iff(_or([_and(goals), _sys(DONE_PROP)]), _next(_sys(DONE_PROP)))) + END
            print >> ltl_file, _parens(ALWAYS + FINALLY + _parens(_or([_sys(DONE_PROP)] + 
                [_sys(actuator) for actuator in self.standing_actuators])))

    def _generate_ltl_file(self, file_prefix, init_room, init_props):
        """Write out the LTL file."""        
        print "Generating starting from %s for rooms:" % init_room
        print self.room_map.keys()
        full_room_props = self.room_map.values()
        
        ltl_file = open(file_prefix + LTL_ENDING, 'w')
        
        # Assumptions first
        self._generate_assumptions(ltl_file)
        
        # Guarantees next
        print >> ltl_file, GUARANTEES_START
        
        # Starting state
        self._generate_starting_state(init_room, init_props, ltl_file)
        
        # Work definition
        self._generate_work_definition(ltl_file)
    
        # Movement
        self._generate_movement(full_room_props, ltl_file)
            
        # Search, only if searching
        if self.search_commands:
            self._generate_search(ltl_file)
        
        # Getting items
        self._generate_get(ltl_file)
        
        # Standing orders
        if self.other_commands:
            self._generate_standing_orders(ltl_file)
        
        # Goals
        self._generate_goals(ltl_file)
        
        # Close the file out
        print >> ltl_file, GUARANTEES_END
        ltl_file.close()

    def generate(self, init_room, init_props, file_prefix, basedir, tells):
        """Generate LTL located at the given location."""            
 
        # Make search flags
        # If there are standing orders or tells in effect, make sure to search the go room
        if self.go_command and (tells or self.other_commands):
            print "Adding search command when going because of active tell/standing orders."
            self.search_commands.append(self.go_command)
        self.search_rooms = [room for room in self.search_commands]
        self.search_props = ["s_" + room for room in self.search_rooms]
        # Hack to cover floor search
        if self.search_rooms == [EXPLORE_REGION]:
            self.explore = True

        # Make get command flags
        self.get_sensors = [owner.lower() for owner, unused in self.get_commands]
        self.get_props = ["get_" + item.lower() for unused, item in self.get_commands]
        self.get_have_props = ["have_" + item.lower() for unused, item in self.get_commands]
        self.get_done_sensors = [GET_DONE_SENSOR]
        
        # Make standing order flags
        self.standing_sensors = [target.lower() for unused, target in self.other_commands]
        self.standing_actuators = [action.lower() for action, unused in self.other_commands]

        # Make the files
        custom_props, actuators = self._generate_smv_file(file_prefix)
        self._generate_ltl_file(file_prefix, init_room, init_props)

        # Run the automaton compilation
        command = (AUTOMATON_GEN % (basedir, basedir)).split() + \
            [file_prefix + SMV_ENDING, file_prefix + LTL_ENDING]
        print "Calling automaton generation using:", command
        result = subprocess.call(command)

        # Raise an exception if it was unrealizable
        if result:
            raise UnrealizableError

        return(file_prefix + AUT_ENDING, custom_props, self.all_sensors, actuators, self.room_map)
    
    def decode_region(self, outputs):
        """Return a region from a state's outputs."""
        if COMPRESS_ROOMS:
            # Get the values for each bit and return the accompanying room
            set_bits = [int(BIT_ROOM_RE.match(key).group(1)) for key, val in outputs.items() 
                        if BIT_ROOM_RE.match(key) and val == '1']
            room = self.num_rooms[sum(2**bit for bit in set_bits)]
            return [room]
        else:
            # Just return whatever matches the room RE
            return [ROOM_RE.match(key).group(1) for key, val in outputs.items() 
                          if ROOM_RE.match(key) and val == '1'] 


def _gen_room_props(rooms):
    """Map the rooms to propositions, compressing if needed."""
    if COMPRESS_ROOMS:
        n_bits = int(math.floor(math.log(len(rooms) - 1, 2))) + 1 if len(rooms) > 1 else 1
        room_nums = dict((room, idx) for idx, room in enumerate(rooms))
        room_map = dict((room, _room_bit_prop(num, n_bits)) 
                                    for room, num in room_nums.items())
        bit_prop_names = [_bit_name(idx) for idx in range(n_bits)]
        return (room_map, bit_prop_names)
    else:
        room_map = dict((room, _sys(ROOM_PREFIX + room)) for room in rooms)
        return (room_map, [ROOM_PREFIX + room for room in rooms])

    
def _room_bit_prop(num, n_bits):
    """Return a proposition representing a room number in compressed form."""
    # Get the binary as a list of characters. Cut off the '0b' at the front.
    bit_strs = [bit for bit in str(bin(num))[2:]]
    # Reverse it (LSB first) and then pad it to length
    bit_strs = bit_strs[::-1]
    bit_strs += ['0'] * (n_bits - len(bit_strs))
    # Now invert each bit or not by checking against a boolean of string 0/1.
    # We reverse the list to put the propositions back in the natural order (MSB first).
    return _and([_sys(_bit_name(idx)) if bool(int(bit)) else _not(_sys(_bit_name(idx))) 
                 for idx, bit in enumerate(bit_strs)][::-1])


def _bit_name(idx):
    """Return the name of a bit proposition corresponding to an index."""
    return BIT_PREFIX + str(idx)


def _space(text):
    """Wrap text in spaces."""
    return " " + text + " "


def _and(propostions, delim=''):
    """Add logical and to the arguments"""
    return _parens((_space(AND) + delim).join(propostions))


def _or(propostions, delim=''):
    """Add logical or to the arguments"""
    return _parens((_space(OR) + delim).join(propostions))


def _parens(text):
    """Wrap text in parens."""
    return "(" + text + ")"


def _always(text):
    """Wrap text in always."""
    return _parens(ALWAYS + _parens(text))


def _always_finally(text):
    """Wrap text in always."""
    return _parens(ALWAYS + FINALLY + _parens(text))


def _not(text):
    """Add a not operator in front of a string."""
    return NOT + text


def _sys(text):
    """Add a robot state marker in front of a string."""
    return ROBOT_STATE + text


def _env(text):
    """Add an environment state marker in front of a string."""
    return ENV_STATE + text


def _next(text):
    """Wrap text in next()."""
    return "next" + _parens(text)


def _mutex(items):
    """Create a system proposition mutex over the given items."""
    return _always(_or([_and([_next(item1)] +
                             [_not(_next(item2)) for item2 in items if item2 != item1]) 
                    for item1 in items], "\n    "))
    
    
def _iff(prop1, prop2):
    """Connect two propositions with if and only if."""
    return _parens(prop1 + _space(IFF) + prop2)


def _implies(prop1, prop2):
    """Connect two propositions with implies."""
    return _parens(prop1 + _space(TO) + prop2)

