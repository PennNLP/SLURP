"""
Functions for handling the semantic structures generated by the semantic parser.
"""

# Copyright (C) 2011-2012 Ian Perera and Constantine Lignos
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import parsing
from lexical_constants import *
from structures import Entity, Assertion, Event, Command, WhQuery

CONDITION_ARGUMENT = 'Condition'


def process_parse_tree(parse_tree_input, text_input, knowledge_base=None):
    """Produces semantic interpretations of parse trees."""

    print "Processing:", repr(text_input)
    semantics_result = parsing.get_semantics_from_parse_tree(parse_tree_input)
    print "Semantics result:", semantics_result
    semantic_structures = parsing.create_semantic_structures(semantics_result)
    print "Semantics structures:", semantic_structures
    if knowledge_base is not None:
        response = knowledge_base.process_semantic_structures(semantic_structures)
        print "Reponse from semantics:", response
    return semantics_result

def parse_semantic_structures(semantic_structure_list):
    """Update belief maps based on Commander's utterance, and (TODO) answer
    queries."""
    new_commands = []
    junior_known_entities = {}
    commander_known_entities = {}
    watch_list = []
    discourse_stack = []
    conditional = (['if'] in semantic_structure_list or ['when'] in semantic_structure_list)
    conditional_command = None
    conditional_event = None
    response = ""
    
    for semantic_structure in semantic_structure_list:
        print "Semantic structure:", semantic_structure
        if str(semantic_structure) == "['if']" or str(semantic_structure) == "['when']":
            continue
        elif str(semantic_structure) == "or":
            continue
        else:
            discourse_stack.append(semantic_structure)

        # Events on their own should be watch requests, events as conditionals
        # should be conditions
        if isinstance(semantic_structure, Event):
            if not conditional:
                print "Adding the following to the semantics watch list:"
                print semantic_structure
                watch_list.append(semantic_structure)
                # Pad response if needed before adding to it.
                if response:
                    response += " "
                response += "I'll let you know if I see a %s." % \
                    (str(semantic_structure.entity_class.predicates['Theme'][0].value))
            else:
                conditional_event = semantic_structure

        # Update knowledge bases with assertions
        if isinstance(semantic_structure, Assertion):
            if semantic_structure.existential is True:
                instances = semantic_structure.entity_class.instantiate()
                for instance in instances:
                    new_entity = Entity(dict(instance.predicates.items() + \
                                    semantic_structure.predicates.items()))
                    junior_known_entities[new_entity.id] = new_entity
                    commander_known_entities[new_entity.id] = new_entity
                    
                    response += "Got it, I now know about the %s." % \
                        str(new_entity.predicates['Theme'][0].value)
                return (new_commands, watch_list, commander_known_entities, response)
            else:
                # TODO: Re-enable and make it actually work
                pass
                #instances = generate_reference_list(\
                #                semantic_structure.entity_class,
                #                commander_known_entities.values())

        # If it's a conditional, we'll add it to the last event
        # If it's not, put it on the queue to be executed when Commander says so
        if isinstance(semantic_structure, Command):
            if conditional:
                conditional_command = semantic_structure
            else:
                _add_command_to_queue(new_commands, semantic_structure)

        # Answer WH-questions
        if isinstance(semantic_structure, WhQuery):
            # TODO: Re-enable
            pass
    
    # Add pointers to events for conditional commands
    if conditional_command and conditional_event:
        conditional_command.condition = conditional_event
        _add_command_to_queue(new_commands, conditional_command)
                                           
    return (new_commands, watch_list, commander_known_entities, response)


def _add_command_to_queue(queue, command):
    """Converts Commands to a <(action,[arguments])> structure to add to the queue, and 
    performs aliasing for entity and action names.
    Hack: Last element in predicate list is usually most accurate."""
    arguments = {}
    
    # Add all predicates to arguments and add the command
    for predicate_type, predicate_list in command.entity_class.predicates.items():
        if predicate_type != 'Agent' and predicate_list:
            arguments[predicate_type] = get_aliased_entity(str(predicate_list[-1].value))
            
    # Handle conditional requirements
    if command.condition:
        arguments[CONDITION_ARGUMENT] = \
            str(command.condition.entity_class.predicates['Theme'][0].value)
                  
    queue.append((command.action, arguments))

def get_aliased_entity(entity_name):
    """Checks the entity dict for a replacement name."""
    if entity_name.lower() in ENTITY_ALIASES:
        return ENTITY_ALIASES[entity_name.lower()]
    elif entity_name == 'here':
        # TODO: Re-enable handling of 'here'
        return 'nowhere'
    else:
        return entity_name
