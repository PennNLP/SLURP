"""
Functions for handling the semantic structures generated by the semantic parser.
"""

# Copyright (C) 2011-2013 Kenton Lee, Constantine Lignos, and Ian Perera
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import parsing
from lexical_constants import ENTITY_ALIASES
from new_structures import Command

CONDITION_ARGUMENT = 'Condition'


def process_parse_tree(parse_tree_input, text_input, knowledge_base=None):
    """Produces semantic interpretations of parse trees."""
    print "Processing:", repr(text_input)

    # Perform tree operations
    frames = parsing.extract_frames_from_parse(parse_tree_input)
    print "Semantic frames:", frames

    # Extract meaning
    semantic_structures = parsing.create_semantic_structures(frames)

    # Update KB
    if knowledge_base:
        kb_response = knowledge_base.process_semantic_structures(semantic_structures)
        print "Response from knowledge base:", kb_response
    else:
        kb_response = ''

    # Extract commands from meaning
    semantics_response = parse_semantic_structures(semantic_structures)
    if knowledge_base:
        knowledge_base.fill_commands(semantics_response[0])
    try:
        new_commands = semantics_response[0]
        user_response = semantics_response[3]
        print "New commands:", new_commands
    except (TypeError, IndexError):
        user_response = ""
        new_commands = []

    return (user_response, frames, semantics_response, new_commands, kb_response)


def parse_semantic_structures(semantic_structure_list):
    """Update belief maps based on Commander's utterance, and (TODO) answer
    queries."""
    new_commands = []
    commander_known_entities = {}
    watch_list = []
    response = ""

    for sem in semantic_structure_list:
        # TODO: Figure out how much of this should be re-enabled or is superseded.
        # TODO: Add support for new conditionals.
#        # Events on their own should be watch requests, events as conditionals
#        # should be conditions
#        if isinstance(semantic_structure, Event):
#            if not conditional:
#                print "Adding the following to the semantics watch list:"
#                print semantic_structure
#                watch_list.append(semantic_structure)
#                # Pad response if needed before adding to it.
#                if response:
#                    response += " "
#                response += "I'll let you know if I see a %s." % \
#                    (str(semantic_structure.entity_class.predicates['Theme'][0].value))
#            else:
#                conditional_event = semantic_structure

        # Update knowledge bases with assertions
#        if isinstance(semantic_structure, Assertion):
#            if semantic_structure.existential is True:
#                instances = semantic_structure.entity_class.instantiate()
#                for instance in instances:
#                    new_entity = Entity(dict(instance.predicates.items() + \
#                                    semantic_structure.predicates.items()))
#                    junior_known_entities[new_entity.id] = new_entity
#                    commander_known_entities[new_entity.id] = new_entity
#
#                    response += "Got it, I now know about the %s." % \
#                        str(new_entity.predicates['Theme'][0].value)
#                return (new_commands, watch_list, commander_known_entities, response)
#            else:
#                # TODO: Re-enable and make it actually work
#                pass
#                # instances = generate_reference_list(\
#                #                semantic_structure.entity_class,
#                #                commander_known_entities.values())

        # If it's a conditional, we'll add it to the last event
        # If it's not, put it on the queue to be executed when Commander says so
        if isinstance(sem, Command):
            new_commands.append(sem)

#        # Answer WH-questions
#        if isinstance(semantic_structure, WhQuery):
#            # TODO: Re-enable
#            pass

    # Add pointers to events for conditional commands
#    if conditional_command and conditional_event:
#        conditional_command.condition = conditional_event
#        _add_command_to_queue(new_commands, conditional_command)

    return (new_commands, watch_list, commander_known_entities, response)


def get_aliased_entity(entity_name):
    """Checks the entity dict for a replacement name."""
    if entity_name.lower() in ENTITY_ALIASES:
        return ENTITY_ALIASES[entity_name.lower()]
    elif entity_name == 'here':
        # TODO: Re-enable handling of 'here'
        return 'nowhere'
    else:
        return entity_name
