"""
Classes used for storing the semantic
structures generated by the semantic parser.
"""

# Copyright (C) 2011-2013 Ian Perera, Kenton Lee, and Constantine Lignos
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from semantics.util import text2int


class Entity:
    """Parent class of entities"""

    TYPES = ['Object', 'Location']
    TYPE_ID = -1  # Subclasses should override TYPE_ID

    def __init__(self, name=None, description=None):
        self.name = name
        self.quantifier = Quantifier()
        # Using mutable object as default argument causes
        # it to be aliased across instances
        self.description = description if description is not None else []

    def merge(self, other):
        """Merge this entity with another entity"""
        if other.name is not None:
            self.name = other.name
        self.quantifier.merge(other.quantifier)
        self.description.extend(other.description)

    def readable(self):
        return '%s %s' % (self.quantifier.readable(), self.name)

    def __str__(self):
        return '%s:\n' % str(self.TYPES[self.TYPE_ID]) + \
            '\t\tName:%s\n' % str(self.name) + \
            '\t\tQuantifier:\n%s\n' % str(self.quantifier) + \
            '\t\tDescription:%s' % str(self.description)

    def __repr__(self):
        return str(self)


class ObjectEntity(Entity):
    """Class representing an object entity"""

    TYPE_ID = 0


class Location(Entity):
    """Class representing a location entity"""

    TYPE_ID = 1


class Quantifier:
    """Class representing a quantifier"""

    # Exactly one parameter should be specified at a time
    def __init__(self, dt=None, cd=None):
        if dt in ('any', 'some'):
            self.definite = False
            self.type = 'any'
            self.number = None
        elif dt in ('a', 'an'):
            self.definite = False
            self.type = 'exact'
            self.number = 1
        elif dt in ('none', 'no'):
            self.definite = True
            self.type = 'none'
            self.number = 0
        elif dt == 'all':
            self.definite = True
            self.type = 'all'
            self.number = None
        else:  # When dt is 'the', None, or unknown
            # Lowest priority when merging
            self.definite = True
            self.type = 'exact'
            self.number = 1
        if cd != None:
            self.number = cd if cd.isdigit() else text2int(cd)

    def readable(self):
        if self.definite:
            if self.type == 'all':
                return self.type
            if self.number == 0:
                return 'no'
            if self.number == 1:
                return 'the'
            else:
                return str(self.number)
        else:
            if self.number == 1:
                return 'a'
            else:
                return 'any'

    def __str__(self):
        return '\t\t\tDefinite:%s\n' % str(self.definite) +\
               '\t\t\tType:%s\n' % str(self.type) +\
               '\t\t\tNumber:%s' % str(self.number)

    def fill_determiner(self, dt):
        """Fills self with a determiner by merging it with
        a new quantifier created with that determiner"""
        self.merge(Quantifier(dt=dt))

    def fill_cardinal(self, cd):
        """Fills self with a cardinal number  by merging it with
        a new quantifier created with that cardinal number"""
        self.merge(Quantifier(cd=cd))

    def merge(self, other):
        """Merge quantifier with other quantifer"""

        # Assume combination of definite and indefinite is definite
        # e.g. some of the rooms
        self.definite = self.definite and other.definite

        # Non-exact types and numbers should take precedence
        if other.type in ('any', 'none', 'all'):
            self.type = other.type

        if other.number != 1:
            self.number = other.number

    def __repr__(self):
        return str(self)


class Assertion:
    """Asserts the existence or property of an Entity in the world."""

    def __init__(self, theme, location, existential=False):
        self.theme = theme
        self.location = location
        self.existential = existential

    def __str__(self):
        return 'Assertion: \n' + \
               '\tTheme: %s\n' % str(self.theme) + \
               '\tLocation: %s\n' % str(self.location) + \
               '\tExistential: %s\n' % str(self.existential)

    def __repr__(self):
        return str(self)


class Query:
    """Base class for all queries"""

    def __init__(self, theme):
        self.theme = theme

    def check_fact(self, fact):
        """ Returns response if query is answered by fact. Returns none otherwise"""
        return None

    def __repr__(self):
        return str(self)

    def __str__(self):
        return 'LocationQuery: \n' + \
               '\tTheme:%s\n' % str(self.theme)


class YNQuery(Query):
    """Yes/No queries."""
    def __init__(self, theme, location):
        self.theme = theme
        self.location = location

    def __str__(self):
        return 'YNQuery: \n' + \
               '\tTheme: %s\n' % str(self.theme) + \
               '\tLocation: %s' % str(self.location)


class LocationQuery(Query):
    """Where queries"""
    pass


class StatusQuery(Query):
    """Status queries"""
    pass


class EntityQuery(Query):
    """Who/What queries"""
    def __init__(self, location):
        self.location = location

    def __str__(self):
        return 'EntityQuery: \n' + \
               '\tLocation:%s\n' % str(self.location)


class Command:
    """A Command for Junior to do something."""

    def __init__(self, agent, theme, patient, location, action,
                 condition=None, negation=False):
        self.agent = agent
        self.theme = theme
        self.patient = patient
        self.location = location
        self.action = action
        self.condition = condition
        self.negation = negation

    def __str__(self):
        return '\nCommand: \n' + \
               '\tAgent:\t' + str(self.agent) + '\n' + \
               '\tAction:' + str(self.action) + '\n' + \
               '\tTheme:\t' + str(self.theme) + '\n' + \
               '\tPatient:\t' + str(self.patient) + '\n' + \
               '\tLocation:\t' + str(self.location) + '\n' + \
               '\tCondition:' + str(self.condition) + '\n' + \
               '\tNegation:' + str(self.negation)

    def __repr__(self):
        return str(self)


class Event:
    """An event in the environment that can trigger a command."""

    def __init__(self, entity, sensor):
        self.entity = entity
        self.sensor = sensor
        self.command = None

    def __str__(self):
        return 'Event:\n' + \
               '\tEntity: ' + str(self.entity) + '\n' +\
               '\tSensor: ' + str(self.sensor) + '\n' +\
               '\tCommand: ' + str(self.command)

    def __repr__(self):
        return str(self)
