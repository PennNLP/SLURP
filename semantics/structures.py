"""
Classes used for storing the semantic structures generated by the semantic parser.
"""

# Copyright (C) 2011-2012 Ian Perera and Constantine Lignos
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from collections import defaultdict

class Predicate:
    """Stores a predicate type, its value, and optional negation. Also stores
    salience for pragmatics."""
    def __init__(self, predicate_type, value = None, negation = False):
        self.predicate_type = predicate_type
        self.value = value
        self.negation = False

    def __eq__(self, other):
        if not hasattr(other, 'predicate_type') or \
           not hasattr(other, 'value') or \
           not hasattr(other, 'negation'):
            return False
        
        return (self.value == other.value and \
               self.predicate_type.lower() == other.predicate_type.lower() and \
               self.negation == other.negation)


    def __str__(self):
        return str(self.predicate_type) + ':' + str(self.value)

    def __repr__(self):
        return self.__str__()

class Entity:
    """Stores a unique id and a list of predicates."""
    next_id = 0
    def __init__(self, predicates = None, new_id = None):
        if new_id:
            self.id = new_id
        else:
            self.id = Entity.next_id
            Entity.next_id = self.id + 1

        if predicates is None:
            self.predicates = defaultdict(list)
        else:
            self.predicates = predicates

        self.relevance = 1.0

    def __str__(self):
        return 'Entity ' + str(self.id) + ': ' + str(self.predicates)

    def __repr__(self):
        return str(self)


class Quantifier:
    """A generalized quantifier class used to pick out the correct number of
    entities from a universe."""
    def __init__(self, plural = None, definite = None, exhaustive = None, \
                 proportionality = 'exact', number = None):
        self.plural = plural
        self.definite = definite
        self.exhaustive = exhaustive
        self.proportionality = proportionality
        self.number = number
        self.fulfilled = True

    def intersect(self, other):
        """TODO: Returns a new quantifier which is the intersection of two quantifiers, or None
        if there is no such quantifier."""
##        new_quantifier = Quantifier()
##
##        if self.plural is True and other.plural is True:
##            new_quantifier.plural = True
##        elif self.plural is False and other.plural is False:
##            new_quantifier.plural = False
##        elif ((self.plural is False and self.exhaustive is False) or
##              (other.plural is False and other.exhaustive is False)):
##            new_quantifier.plural = True
##        else:
##            new_quantifier.plural = True

    def subsumes(self, other):
        if self.plural is True and self.exhaustive is True and other.plural is False:
            return False

        if (self.proportionality == 'at least' and (other.proportionality == 'at most' or
                                                   other.proportionality == 'exact')
                                                and other.number <= self.number):
            return False

        if (self.proportionality == 'exact' and other.proportionality == 'exact' and
            self.number != other.number):
            return False

        return True


    def __str__(self):
        return 'Quantifier: \n' + \
               '\tPlural: ' + str(self.plural) + '\n' +\
               '\tDefinite: ' + str(self.definite) + '\n' +\
               '\tExhaustive: ' + str(self.exhaustive) + '\n' +\
               '\tProportionality: ' + str(self.proportionality) + '\n' +\
               '\tNumber: ' + str(self.number) + '\n'

    def __repr__(self):
        return self.__str__()

class EntityClass:
    """A quantifier and a list of predicates representing a reference to a set
    of Entities."""
    def __init__(self, quantifier, predicates):
        self.quantifier = quantifier
        self.predicates = predicates

    def instantiate(self):
        """Creates a number of entities with this class's predicates according to
        the quantifier."""
        if self.quantifier.number is not None:
            return [Entity(self.predicates) \
                        for i in range(int(self.quantifier.number))]
        else:
            return []


    def __str__(self):
        return 'EntityClass: \n' + \
               '\t\t' + str(self.quantifier) + '\n' +\
               '\t\tPredicates: ' + str(self.predicates.values())

    def __repr__(self):
        return self.__str__()

class Assertion:
    """Asserts the existence or property of an Entity in the world."""
    def __init__(self, entity_class, predicates, existential = False):
        self.entity_class = entity_class
        self.predicates = predicates
        self.existential = existential

    def __str__(self):
        return 'Assertion: \n' + \
               '\t' + str(self.entity_class) + '\n' +\
               '\tPredicates: ' + str(self.predicates.values()) +\
               '\n\tExistential: ' + str(self.existential)

    def __repr__(self):
        return self.__str__()
        

class YNQuery:
    """Yes/No queries."""
    def __init__(self, entity_class):
        self.entity_class = entity_class

    def __str__(self):
        return 'YNQuery: \n' + \
               '\tEntityClass: ' + str(self.entity_class) + '\n'

    def __repr__(self):
        return self.__str__()

class WhQuery:
    """A Wh-query, which contains the EntityClass in question and the predicate
    being queried."""
    def __init__(self, entity_class, predicate_type):
        self.entity_class = entity_class
        self.predicate_type = predicate_type

    def __str__(self):
        return 'WhQuery: \n' + \
               '\tEntityClass: ' + str(self.entity_class) + '\n' + \
               '\tType: '  + str(self.predicate_type) + '\n'

    def __repr__(self):
        return self.__str__()

class Command:
    """A Command for Junior to do something."""
    def __init__(self, entity_class, action, condition=None, negation = False):
        self.entity_class = entity_class
        self.action = action
        self.condition = condition
        self.negation = negation

    def __str__(self):
        return 'Command: \n' + \
               '\tEntityClass: ' + str(self.entity_class) + '\n' + \
               '\tAction: ' + str(self.action) + '\n' + \
               '\tCondition: ' + str(self.condition) + '\n' + \
               '\tNegation: ' + str(self.negation)
    def __repr__(self):
        return self.__str__()

class Event:
    """An event in the environment that can trigger a command."""
    def __init__(self, entity_class, sensor):
        self.entity_class = entity_class
        self.sensor = sensor
        self.command = None

    def __str__(self):
        return 'Event:\n' + \
               '\tEntityClass: ' + str(self.entity_class) + '\n' +\
               '\tSensor: ' + str(self.sensor) +'\n' +\
               '\tCommand: ' + str(self.command)

    def __repr__(self):
        return self.__str__()

